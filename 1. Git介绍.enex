<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">
<en-export export-date="20180625T022940Z" application="Evernote/Windows" version="6.x">
<note><title>1. Git介绍</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note><div><ol start="1"><li>Git是一个分布式版本控制系统；</li><ol><li>分布式版本控制系统与SVN等集中式版本控制系统的区别：</li><ol><li>针对集中式：版本库存放在中央服务器，但是代码编写是在本地服务器，因此每次工作前都必须先从中央服务器下载最新版本，然后才能工作，结束之后还得手动提交给中央服务器；</li><ol><li>中央服务器权限过大，如果中央服务器挂掉，则很难进行恢复；</li><li>必须通过联网才能工作，受限于网速；</li></ol><li>而分布式：每人本地中都含有完整的版本库，工作时无需联网，直接可以修改；而在协作时，只需要将各自版本修改内容推送给对方即可；</li><ol><li>安全性较强：每个人电脑上都是完整版本库，如果其中一个节点损坏，可以从其他节点直接复制过去；</li><li>也可以添加一个中央仓库，主要用于方便交换修改内容，其内容与每个人内部都可以的；<br/><br/></li></ol><li>Git本地仓库包含代码库和历史库，本地环境开发就自动记录历史；而SVN等集中式的历史库存在于中央仓库，只有代码库，导致每次提交、对比代码都只能连接中央仓库才能进行；<br/><br/></li></ol></ol><li>Git面向的是修改而非文件：</li><ol><li>如果使用下面的流程：修改文件 -&gt; git add -&gt;&nbsp;修改文件 -&gt; git commit，则提交操作完成之后实际只是对第一次的修改进行提交，而第二次修改操作并没有提交，这是因为提交的是git add中暂存区的修改内容，而第二次修改没有使用git add加入到暂存区中，因此不会被提交；</li><li>而对于上面的操作，调用git status将显示版本不对应；</li><li>可以是按照这样的流程：修改文件 -&gt; git add -&gt;&nbsp;修改文件 -&gt; git add -&gt; git commit；即，将两次修改分别存储到暂存区中，然后最后一起提交；<br/><br/></li><li>为什么说Git面向修改：因为针对修改同一个文件，如果是面向文件的系统，则针对上面的流程1，将会把最终文件进行提交，因此第二次修改的内容应该也会生效；但是由于Git面向修改，仅对于git add的修改进行提交，从而导致第二次没有提交的修改不能生效；</li><li>因此在每次修改过之后，需要使用git&nbsp;add将修改提交到暂存区中；</li></ol></ol></div><div><br/></div></en-note>]]></content><created>20180614T061310Z</created><updated>20180614T074005Z</updated><note-attributes><author>周广振</author><source>desktop.win</source><source-application>evernote.win32</source-application></note-attributes></note></en-export>
